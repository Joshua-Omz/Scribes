# Flutter Cross-Reference Feature Implementation Guide

## Overview

This guide provides a complete implementation of the Cross-Reference (CrossRef) feature for your Flutter app, integrating with the Scribes backend API. The CrossRef feature allows users to create connections between related sermon notes, building a knowledge graph of their spiritual insights.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Project Structure](#project-structure)
3. [Data Models](#data-models)
4. [API Service](#api-service)
5. [Repository Layer](#repository-layer)
6. [State Management](#state-management)
7. [UI Components](#ui-components)
8. [Complete Code Examples](#complete-code-examples)

---

## Prerequisites

Ensure you have the following packages in your `pubspec.yaml`:

```yaml
dependencies:
  flutter:
    sdk: flutter
  
  # HTTP Client
  dio: ^5.4.0
  
  # State Management
  flutter_riverpod: ^2.4.9
  
  # Secure Storage
  flutter_secure_storage: ^9.0.0
  
  # Local Storage
  shared_preferences: ^2.2.2
  
  # JSON Serialization
  json_annotation: ^4.8.1
  
  # Date Formatting
  intl: ^0.18.1
  
  # Graph visualization (optional)
  graphview: ^1.2.0

dev_dependencies:
  # Code Generation
  build_runner: ^2.4.7
  json_serializable: ^6.7.1
```

---

## Project Structure

```
lib/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ cross_ref.dart
‚îÇ   ‚îî‚îÄ‚îÄ cross_ref.g.dart (generated)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ api_client.dart
‚îÇ   ‚îî‚îÄ‚îÄ cross_ref_api_service.dart
‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îî‚îÄ‚îÄ cross_ref_repository.dart
‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îî‚îÄ‚îÄ cross_ref_provider.dart
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ cross_refs_screen.dart
‚îÇ   ‚îú‚îÄ‚îÄ create_cross_ref_screen.dart
‚îÇ   ‚îî‚îÄ‚îÄ note_graph_screen.dart (optional)
‚îî‚îÄ‚îÄ widgets/
    ‚îú‚îÄ‚îÄ cross_ref_card.dart
    ‚îú‚îÄ‚îÄ cross_ref_list.dart
    ‚îî‚îÄ‚îÄ reference_type_chip.dart
```

---

## Data Models

### 1. CrossRef Model (`lib/models/cross_ref.dart`)

```dart
import 'package:json_annotation/json_annotation.dart';

part 'cross_ref.g.dart';

/// Reference types for cross-references
enum ReferenceType {
  related,
  references,
  @JsonValue('cited_by')
  citedBy,
  @JsonValue('expands_on')
  expandsOn,
  contradicts,
  supports,
  follows,
  precedes,
}

/// Auto-generation types
enum AutoGenerationType {
  manual,
  @JsonValue('ai_suggested')
  aiSuggested,
  @JsonValue('ai_auto')
  aiAuto,
}

@JsonSerializable()
class CrossRef {
  final int id;
  @JsonKey(name: 'note_id')
  final int noteId;
  @JsonKey(name: 'other_note_id')
  final int otherNoteId;
  @JsonKey(name: 'reference_type')
  final String referenceType;
  final String? description;
  @JsonKey(name: 'is_auto_generated')
  final String isAutoGenerated;
  @JsonKey(name: 'confidence_score')
  final int? confidenceScore;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;

  CrossRef({
    required this.id,
    required this.noteId,
    required this.otherNoteId,
    required this.referenceType,
    this.description,
    required this.isAutoGenerated,
    this.confidenceScore,
    required this.createdAt,
  });

  factory CrossRef.fromJson(Map<String, dynamic> json) => 
      _$CrossRefFromJson(json);
  Map<String, dynamic> toJson() => _$CrossRefToJson(this);
}

@JsonSerializable()
class CrossRefWithNoteDetails {
  final int id;
  @JsonKey(name: 'note_id')
  final int noteId;
  @JsonKey(name: 'other_note_id')
  final int otherNoteId;
  @JsonKey(name: 'reference_type')
  final String referenceType;
  final String? description;
  @JsonKey(name: 'is_auto_generated')
  final String isAutoGenerated;
  @JsonKey(name: 'confidence_score')
  final int? confidenceScore;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'note_title')
  final String? noteTitle;
  @JsonKey(name: 'note_preview')
  final String? notePreview;
  @JsonKey(name: 'other_note_title')
  final String? otherNoteTitle;
  @JsonKey(name: 'other_note_preview')
  final String? otherNotePreview;

  CrossRefWithNoteDetails({
    required this.id,
    required this.noteId,
    required this.otherNoteId,
    required this.referenceType,
    this.description,
    required this.isAutoGenerated,
    this.confidenceScore,
    required this.createdAt,
    this.noteTitle,
    this.notePreview,
    this.otherNoteTitle,
    this.otherNotePreview,
  });

  factory CrossRefWithNoteDetails.fromJson(Map<String, dynamic> json) => 
      _$CrossRefWithNoteDetailsFromJson(json);
  Map<String, dynamic> toJson() => _$CrossRefWithNoteDetailsToJson(this);
}

@JsonSerializable()
class CrossRefCreate {
  @JsonKey(name: 'note_id')
  final int noteId;
  @JsonKey(name: 'other_note_id')
  final int otherNoteId;
  @JsonKey(name: 'reference_type')
  final String referenceType;
  final String? description;
  @JsonKey(name: 'is_auto_generated')
  final String? isAutoGenerated;
  @JsonKey(name: 'confidence_score')
  final int? confidenceScore;

  CrossRefCreate({
    required this.noteId,
    required this.otherNoteId,
    this.referenceType = 'related',
    this.description,
    this.isAutoGenerated,
    this.confidenceScore,
  });

  factory CrossRefCreate.fromJson(Map<String, dynamic> json) => 
      _$CrossRefCreateFromJson(json);
  Map<String, dynamic> toJson() => _$CrossRefCreateToJson(this);
}

@JsonSerializable()
class CrossRefUpdate {
  @JsonKey(name: 'reference_type')
  final String? referenceType;
  final String? description;
  @JsonKey(name: 'is_auto_generated')
  final String? isAutoGenerated;
  @JsonKey(name: 'confidence_score')
  final int? confidenceScore;

  CrossRefUpdate({
    this.referenceType,
    this.description,
    this.isAutoGenerated,
    this.confidenceScore,
  });

  factory CrossRefUpdate.fromJson(Map<String, dynamic> json) => 
      _$CrossRefUpdateFromJson(json);
  Map<String, dynamic> toJson() => _$CrossRefUpdateToJson(this);
}

@JsonSerializable()
class CrossRefListResponse {
  @JsonKey(name: 'cross_refs')
  final List<CrossRefWithNoteDetails> crossRefs;
  final int total;
  final int skip;
  final int limit;

  CrossRefListResponse({
    required this.crossRefs,
    required this.total,
    required this.skip,
    required this.limit,
  });

  factory CrossRefListResponse.fromJson(Map<String, dynamic> json) => 
      _$CrossRefListResponseFromJson(json);
  Map<String, dynamic> toJson() => _$CrossRefListResponseToJson(this);
}

@JsonSerializable()
class CrossRefCount {
  @JsonKey(name: 'note_id')
  final int noteId;
  @JsonKey(name: 'total_cross_refs')
  final int totalCrossRefs;
  @JsonKey(name: 'outgoing_refs')
  final int outgoingRefs;
  @JsonKey(name: 'incoming_refs')
  final int incomingRefs;

  CrossRefCount({
    required this.noteId,
    required this.totalCrossRefs,
    required this.outgoingRefs,
    required this.incomingRefs,
  });

  factory CrossRefCount.fromJson(Map<String, dynamic> json) => 
      _$CrossRefCountFromJson(json);
  Map<String, dynamic> toJson() => _$CrossRefCountToJson(this);
}

// Helper functions for reference types
extension ReferenceTypeExtension on String {
  String get displayName {
    switch (this) {
      case 'related':
        return 'Related';
      case 'references':
        return 'References';
      case 'cited_by':
        return 'Cited By';
      case 'expands_on':
        return 'Expands On';
      case 'contradicts':
        return 'Contradicts';
      case 'supports':
        return 'Supports';
      case 'follows':
        return 'Follows';
      case 'precedes':
        return 'Precedes';
      default:
        return this;
    }
  }

  String get icon {
    switch (this) {
      case 'related':
        return 'üîó';
      case 'references':
        return 'üìñ';
      case 'cited_by':
        return 'üìù';
      case 'expands_on':
        return 'üîç';
      case 'contradicts':
        return '‚ö†Ô∏è';
      case 'supports':
        return '‚úÖ';
      case 'follows':
        return '‚û°Ô∏è';
      case 'precedes':
        return '‚¨ÖÔ∏è';
      default:
        return 'üîó';
    }
  }
}
```

After creating the model, run:
```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

---

## API Service

### 1. CrossRef API Service (`lib/services/cross_ref_api_service.dart`)

```dart
import 'package:dio/dio.dart';
import '../models/cross_ref.dart';

class CrossRefApiService {
  final Dio _dio;

  CrossRefApiService(this._dio);

  /// Create a new cross-reference
  Future<CrossRefWithNoteDetails> createCrossRef(CrossRefCreate data) async {
    try {
      final response = await _dio.post(
        '/cross-refs/',
        data: data.toJson(),
      );
      return CrossRefWithNoteDetails.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Get a specific cross-reference by ID
  Future<CrossRefWithNoteDetails> getCrossRefById(int crossRefId) async {
    try {
      final response = await _dio.get('/cross-refs/$crossRefId');
      return CrossRefWithNoteDetails.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Get all cross-references for a note (bidirectional)
  Future<CrossRefListResponse> getCrossRefsForNote({
    required int noteId,
    int skip = 0,
    int limit = 50,
  }) async {
    try {
      final response = await _dio.get(
        '/cross-refs/note/$noteId',
        queryParameters: {
          'skip': skip,
          'limit': limit,
        },
      );
      return CrossRefListResponse.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Get outgoing cross-references from a note
  Future<CrossRefListResponse> getOutgoingRefs({
    required int noteId,
    int skip = 0,
    int limit = 50,
  }) async {
    try {
      final response = await _dio.get(
        '/cross-refs/note/$noteId/outgoing',
        queryParameters: {
          'skip': skip,
          'limit': limit,
        },
      );
      return CrossRefListResponse.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Get incoming cross-references to a note
  Future<CrossRefListResponse> getIncomingRefs({
    required int noteId,
    int skip = 0,
    int limit = 50,
  }) async {
    try {
      final response = await _dio.get(
        '/cross-refs/note/$noteId/incoming',
        queryParameters: {
          'skip': skip,
          'limit': limit,
        },
      );
      return CrossRefListResponse.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Update an existing cross-reference
  Future<CrossRefWithNoteDetails> updateCrossRef(
    int crossRefId,
    CrossRefUpdate data,
  ) async {
    try {
      final response = await _dio.put(
        '/cross-refs/$crossRefId',
        data: data.toJson(),
      );
      return CrossRefWithNoteDetails.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Delete a cross-reference
  Future<void> deleteCrossRef(int crossRefId) async {
    try {
      await _dio.delete('/cross-refs/$crossRefId');
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Get cross-reference statistics for a note
  Future<CrossRefCount> getCrossRefCount(int noteId) async {
    try {
      final response = await _dio.get('/cross-refs/note/$noteId/count');
      return CrossRefCount.fromJson(response.data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Bulk create cross-references
  Future<List<CrossRefWithNoteDetails>> bulkCreateCrossRefs({
    required List<CrossRefCreate> crossRefs,
    bool skipErrors = false,
  }) async {
    try {
      final response = await _dio.post(
        '/cross-refs/bulk',
        data: {
          'cross_refs': crossRefs.map((cr) => cr.toJson()).toList(),
          'skip_errors': skipErrors,
        },
      );
      return (response.data['cross_refs'] as List)
          .map((json) => CrossRefWithNoteDetails.fromJson(json))
          .toList();
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  String _handleError(DioException e) {
    if (e.response != null) {
      final data = e.response!.data;
      if (data is Map && data.containsKey('detail')) {
        return data['detail'].toString();
      }
      return 'Server error: ${e.response!.statusCode}';
    }
    return 'Network error: ${e.message}';
  }
}
```

---

## Repository Layer

### 1. CrossRef Repository (`lib/repositories/cross_ref_repository.dart`)

```dart
import '../models/cross_ref.dart';
import '../services/cross_ref_api_service.dart';

class CrossRefRepository {
  final CrossRefApiService _apiService;

  CrossRefRepository(this._apiService);

  Future<CrossRefWithNoteDetails> createCrossRef(CrossRefCreate data) async {
    return await _apiService.createCrossRef(data);
  }

  Future<CrossRefWithNoteDetails> getCrossRefById(int crossRefId) async {
    return await _apiService.getCrossRefById(crossRefId);
  }

  Future<CrossRefListResponse> getCrossRefsForNote({
    required int noteId,
    int skip = 0,
    int limit = 50,
  }) async {
    return await _apiService.getCrossRefsForNote(
      noteId: noteId,
      skip: skip,
      limit: limit,
    );
  }

  Future<CrossRefListResponse> getOutgoingRefs({
    required int noteId,
    int skip = 0,
    int limit = 50,
  }) async {
    return await _apiService.getOutgoingRefs(
      noteId: noteId,
      skip: skip,
      limit: limit,
    );
  }

  Future<CrossRefListResponse> getIncomingRefs({
    required int noteId,
    int skip = 0,
    int limit = 50,
  }) async {
    return await _apiService.getIncomingRefs(
      noteId: noteId,
      skip: skip,
      limit: limit,
    );
  }

  Future<CrossRefWithNoteDetails> updateCrossRef(
    int crossRefId,
    CrossRefUpdate data,
  ) async {
    return await _apiService.updateCrossRef(crossRefId, data);
  }

  Future<void> deleteCrossRef(int crossRefId) async {
    await _apiService.deleteCrossRef(crossRefId);
  }

  Future<CrossRefCount> getCrossRefCount(int noteId) async {
    return await _apiService.getCrossRefCount(noteId);
  }

  Future<List<CrossRefWithNoteDetails>> bulkCreateCrossRefs({
    required List<CrossRefCreate> crossRefs,
    bool skipErrors = false,
  }) async {
    return await _apiService.bulkCreateCrossRefs(
      crossRefs: crossRefs,
      skipErrors: skipErrors,
    );
  }
}
```

---

## State Management

### 1. CrossRef Provider (`lib/providers/cross_ref_provider.dart`)

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/cross_ref.dart';
import '../repositories/cross_ref_repository.dart';
import '../services/api_client.dart';
import '../services/cross_ref_api_service.dart';

// Provider for CrossRefRepository
final crossRefRepositoryProvider = Provider<CrossRefRepository>((ref) {
  final dio = ref.watch(apiClientProvider);
  final apiService = CrossRefApiService(dio);
  return CrossRefRepository(apiService);
});

// State for cross-references
class CrossRefsState {
  final List<CrossRefWithNoteDetails> crossRefs;
  final bool isLoading;
  final String? error;
  final int total;

  CrossRefsState({
    this.crossRefs = const [],
    this.isLoading = false,
    this.error,
    this.total = 0,
  });

  CrossRefsState copyWith({
    List<CrossRefWithNoteDetails>? crossRefs,
    bool? isLoading,
    String? error,
    int? total,
  }) {
    return CrossRefsState(
      crossRefs: crossRefs ?? this.crossRefs,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      total: total ?? this.total,
    );
  }
}

// CrossRefs Notifier
class CrossRefsNotifier extends StateNotifier<CrossRefsState> {
  final CrossRefRepository _repository;

  CrossRefsNotifier(this._repository) : super(CrossRefsState());

  Future<void> loadCrossRefsForNote(int noteId) async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      final response = await _repository.getCrossRefsForNote(noteId: noteId);
      state = CrossRefsState(
        crossRefs: response.crossRefs,
        isLoading: false,
        total: response.total,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<CrossRefWithNoteDetails?> createCrossRef(CrossRefCreate data) async {
    try {
      final crossRef = await _repository.createCrossRef(data);
      state = state.copyWith(
        crossRefs: [...state.crossRefs, crossRef],
        total: state.total + 1,
      );
      return crossRef;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }

  Future<CrossRefWithNoteDetails?> updateCrossRef(
    int crossRefId,
    CrossRefUpdate data,
  ) async {
    try {
      final updatedCrossRef = await _repository.updateCrossRef(crossRefId, data);
      final index = state.crossRefs.indexWhere((cr) => cr.id == crossRefId);
      if (index != -1) {
        final newCrossRefs = [...state.crossRefs];
        newCrossRefs[index] = updatedCrossRef;
        state = state.copyWith(crossRefs: newCrossRefs);
      }
      return updatedCrossRef;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }

  Future<bool> deleteCrossRef(int crossRefId) async {
    try {
      await _repository.deleteCrossRef(crossRefId);
      state = state.copyWith(
        crossRefs: state.crossRefs.where((cr) => cr.id != crossRefId).toList(),
        total: state.total - 1,
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}

// Provider for CrossRefsNotifier
final crossRefsProvider = StateNotifierProvider<CrossRefsNotifier, CrossRefsState>((ref) {
  final repository = ref.watch(crossRefRepositoryProvider);
  return CrossRefsNotifier(repository);
});

// Provider for cross-reference count
final crossRefCountProvider = FutureProvider.family<CrossRefCount, int>((ref, noteId) async {
  final repository = ref.watch(crossRefRepositoryProvider);
  return await repository.getCrossRefCount(noteId);
});

// Provider for a single cross-reference
final crossRefProvider = FutureProvider.family<CrossRefWithNoteDetails, int>((ref, crossRefId) async {
  final repository = ref.watch(crossRefRepositoryProvider);
  return await repository.getCrossRefById(crossRefId);
});
```

---

## UI Components

### 1. Cross-References Screen (`lib/screens/cross_refs_screen.dart`)

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/cross_ref.dart';
import '../providers/cross_ref_provider.dart';
import '../widgets/cross_ref_card.dart';
import 'create_cross_ref_screen.dart';

class CrossRefsScreen extends ConsumerStatefulWidget {
  final int noteId;
  final String noteTitle;

  const CrossRefsScreen({
    super.key,
    required this.noteId,
    required this.noteTitle,
  });

  @override
  ConsumerState<CrossRefsScreen> createState() => _CrossRefsScreenState();
}

class _CrossRefsScreenState extends ConsumerState<CrossRefsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
    Future.microtask(() {
      ref.read(crossRefsProvider.notifier).loadCrossRefsForNote(widget.noteId);
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final crossRefsState = ref.watch(crossRefsProvider);
    final countAsync = ref.watch(crossRefCountProvider(widget.noteId));

    return Scaffold(
      appBar: AppBar(
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Cross References', style: TextStyle(fontSize: 16)),
            Text(
              widget.noteTitle,
              style: const TextStyle(fontSize: 12, fontWeight: FontWeight.normal),
              maxLines: 1,
              overflow: TextOverflow.ellipsis,
            ),
          ],
        ),
        bottom: TabBar(
          controller: _tabController,
          tabs: [
            Tab(
              child: countAsync.when(
                data: (count) => Text('All (${count.totalCrossRefs})'),
                loading: () => const Text('All'),
                error: (_, __) => const Text('All'),
              ),
            ),
            Tab(
              child: countAsync.when(
                data: (count) => Text('Outgoing (${count.outgoingRefs})'),
                loading: () => const Text('Outgoing'),
                error: (_, __) => const Text('Outgoing'),
              ),
            ),
            Tab(
              child: countAsync.when(
                data: (count) => Text('Incoming (${count.incomingRefs})'),
                loading: () => const Text('Incoming'),
                error: (_, __) => const Text('Incoming'),
              ),
            ),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              ref.read(crossRefsProvider.notifier).loadCrossRefsForNote(widget.noteId);
              ref.refresh(crossRefCountProvider(widget.noteId));
            },
          ),
        ],
      ),
      body: TabBarView(
        controller: _tabController,
        children: [
          _buildAllCrossRefs(crossRefsState),
          _buildFilteredCrossRefs(crossRefsState, isOutgoing: true),
          _buildFilteredCrossRefs(crossRefsState, isOutgoing: false),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () async {
          final result = await Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => CreateCrossRefScreen(sourceNoteId: widget.noteId),
            ),
          );
          if (result == true) {
            ref.read(crossRefsProvider.notifier).loadCrossRefsForNote(widget.noteId);
            ref.refresh(crossRefCountProvider(widget.noteId));
          }
        },
        icon: const Icon(Icons.add_link),
        label: const Text('Add Reference'),
      ),
    );
  }

  Widget _buildAllCrossRefs(CrossRefsState state) {
    if (state.isLoading && state.crossRefs.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.error != null && state.crossRefs.isEmpty) {
      return _buildError(state.error!);
    }

    if (state.crossRefs.isEmpty) {
      return _buildEmpty();
    }

    return RefreshIndicator(
      onRefresh: () => ref.read(crossRefsProvider.notifier).loadCrossRefsForNote(widget.noteId),
      child: ListView.builder(
        padding: const EdgeInsets.all(8),
        itemCount: state.crossRefs.length,
        itemBuilder: (context, index) {
          final crossRef = state.crossRefs[index];
          return CrossRefCard(
            crossRef: crossRef,
            currentNoteId: widget.noteId,
            onDelete: () => _deleteCrossRef(crossRef.id),
            onEdit: () => _editCrossRef(crossRef),
          );
        },
      ),
    );
  }

  Widget _buildFilteredCrossRefs(CrossRefsState state, {required bool isOutgoing}) {
    if (state.isLoading && state.crossRefs.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    final filteredRefs = state.crossRefs.where((cr) {
      return isOutgoing ? cr.noteId == widget.noteId : cr.otherNoteId == widget.noteId;
    }).toList();

    if (filteredRefs.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              isOutgoing ? Icons.arrow_forward : Icons.arrow_back,
              size: 64,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              isOutgoing ? 'No outgoing references' : 'No incoming references',
              style: TextStyle(fontSize: 18, color: Colors.grey[600]),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(8),
      itemCount: filteredRefs.length,
      itemBuilder: (context, index) {
        final crossRef = filteredRefs[index];
        return CrossRefCard(
          crossRef: crossRef,
          currentNoteId: widget.noteId,
          onDelete: () => _deleteCrossRef(crossRef.id),
          onEdit: () => _editCrossRef(crossRef),
        );
      },
    );
  }

  Widget _buildError(String error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 64, color: Colors.red),
          const SizedBox(height: 16),
          Text(
            'Error: $error',
            textAlign: TextAlign.center,
            style: const TextStyle(color: Colors.red),
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: () {
              ref.read(crossRefsProvider.notifier).loadCrossRefsForNote(widget.noteId);
            },
            child: const Text('Retry'),
          ),
        ],
      ),
    );
  }

  Widget _buildEmpty() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.link_off, size: 64, color: Colors.grey[400]),
          const SizedBox(height: 16),
          Text(
            'No cross-references yet',
            style: TextStyle(fontSize: 18, color: Colors.grey[600]),
          ),
          const SizedBox(height: 8),
          Text(
            'Tap + to link related notes',
            style: TextStyle(color: Colors.grey[500]),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteCrossRef(int crossRefId) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Cross-Reference'),
        content: const Text('Are you sure you want to delete this cross-reference?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (confirm == true) {
      final success = await ref.read(crossRefsProvider.notifier).deleteCrossRef(crossRefId);
      if (mounted) {
        if (success) {
          ref.refresh(crossRefCountProvider(widget.noteId));
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Cross-reference deleted')),
          );
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Failed to delete cross-reference')),
          );
        }
      }
    }
  }

  Future<void> _editCrossRef(CrossRefWithNoteDetails crossRef) async {
    // TODO: Implement edit dialog
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Edit functionality coming soon')),
    );
  }
}
```

### 2. Create Cross-Reference Screen (`lib/screens/create_cross_ref_screen.dart`)

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/cross_ref.dart';
import '../models/note.dart';
import '../providers/cross_ref_provider.dart';
import '../providers/notes_provider.dart';

class CreateCrossRefScreen extends ConsumerStatefulWidget {
  final int sourceNoteId;

  const CreateCrossRefScreen({super.key, required this.sourceNoteId});

  @override
  ConsumerState<CreateCrossRefScreen> createState() => _CreateCrossRefScreenState();
}

class _CreateCrossRefScreenState extends ConsumerState<CreateCrossRefScreen> {
  final _formKey = GlobalKey<FormState>();
  final _descriptionController = TextEditingController();
  Note? _selectedTargetNote;
  String _selectedReferenceType = 'related';
  bool _isLoading = false;

  final List<String> _referenceTypes = [
    'related',
    'references',
    'cited_by',
    'expands_on',
    'contradicts',
    'supports',
    'follows',
    'precedes',
  ];

  @override
  void initState() {
    super.initState();
    // Load notes for selection
    Future.microtask(() {
      ref.read(notesProvider.notifier).loadNotes(refresh: true);
    });
  }

  @override
  void dispose() {
    _descriptionController.dispose();
    super.dispose();
  }

  Future<void> _createCrossRef() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedTargetNote == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a target note')),
      );
      return;
    }

    setState(() => _isLoading = true);

    final crossRefData = CrossRefCreate(
      noteId: widget.sourceNoteId,
      otherNoteId: _selectedTargetNote!.id,
      referenceType: _selectedReferenceType,
      description: _descriptionController.text.trim().isEmpty
          ? null
          : _descriptionController.text.trim(),
      isAutoGenerated: 'manual',
    );

    final crossRef = await ref.read(crossRefsProvider.notifier).createCrossRef(crossRefData);

    if (mounted) {
      setState(() => _isLoading = false);

      if (crossRef != null) {
        Navigator.pop(context, true);
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Cross-reference created successfully')),
        );
      } else {
        final error = ref.read(crossRefsProvider).error;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: ${error ?? "Unknown error"}')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final notesState = ref.watch(notesProvider);
    final availableNotes = notesState.notes
        .where((note) => note.id != widget.sourceNoteId)
        .toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Cross-Reference'),
        actions: [
          if (_isLoading)
            const Center(
              child: Padding(
                padding: EdgeInsets.all(16.0),
                child: CircularProgressIndicator(color: Colors.white),
              ),
            )
          else
            IconButton(
              icon: const Icon(Icons.check),
              onPressed: _createCrossRef,
            ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // Target note selection
            Card(
              child: ListTile(
                leading: const Icon(Icons.note),
                title: const Text('Target Note'),
                subtitle: _selectedTargetNote == null
                    ? const Text('Select a note to link')
                    : Text(_selectedTargetNote!.title),
                trailing: const Icon(Icons.arrow_forward_ios, size: 16),
                onTap: () => _showNoteSelectionDialog(availableNotes),
              ),
            ),
            const SizedBox(height: 16),

            // Reference type selection
            DropdownButtonFormField<String>(
              value: _selectedReferenceType,
              decoration: const InputDecoration(
                labelText: 'Reference Type',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.category),
              ),
              items: _referenceTypes.map((type) {
                return DropdownMenuItem(
                  value: type,
                  child: Row(
                    children: [
                      Text(type.icon),
                      const SizedBox(width: 8),
                      Text(type.displayName),
                    ],
                  ),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() => _selectedReferenceType = value);
                }
              },
            ),
            const SizedBox(height: 16),

            // Description field
            TextFormField(
              controller: _descriptionController,
              decoration: const InputDecoration(
                labelText: 'Description (Optional)',
                hintText: 'Describe the relationship between these notes',
                border: OutlineInputBorder(),
                alignLabelWithHint: true,
              ),
              maxLines: 4,
              textInputAction: TextInputAction.newline,
            ),
            const SizedBox(height: 24),

            // Reference type descriptions
            _buildReferenceTypeInfo(),
          ],
        ),
      ),
    );
  }

  Future<void> _showNoteSelectionDialog(List<Note> notes) async {
    if (notes.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No other notes available to link')),
      );
      return;
    }

    final selected = await showDialog<Note>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Select Target Note'),
        content: SizedBox(
          width: double.maxFinite,
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: notes.length,
            itemBuilder: (context, index) {
              final note = notes[index];
              return ListTile(
                title: Text(note.title),
                subtitle: Text(
                  note.content,
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                onTap: () => Navigator.pop(context, note),
              );
            },
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
        ],
      ),
    );

    if (selected != null) {
      setState(() => _selectedTargetNote = selected);
    }
  }

  Widget _buildReferenceTypeInfo() {
    return Card(
      color: Colors.blue[50],
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Reference Type Guide',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            _buildTypeDescription('related', 'General relationship between notes'),
            _buildTypeDescription('references', 'This note references the other'),
            _buildTypeDescription('cited_by', 'This note is cited by the other'),
            _buildTypeDescription('expands_on', 'This note expands on the other'),
            _buildTypeDescription('contradicts', 'This note contradicts the other'),
            _buildTypeDescription('supports', 'This note supports the other'),
            _buildTypeDescription('follows', 'This note follows the other chronologically'),
            _buildTypeDescription('precedes', 'This note precedes the other chronologically'),
          ],
        ),
      ),
    );
  }

  Widget _buildTypeDescription(String type, String description) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(type.icon),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              '${type.displayName}: $description',
              style: const TextStyle(fontSize: 12),
            ),
          ),
        ],
      ),
    );
  }
}
```

### 3. Cross-Reference Card Widget (`lib/widgets/cross_ref_card.dart`)

```dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../models/cross_ref.dart';
import '../screens/note_detail_screen.dart';

class CrossRefCard extends StatelessWidget {
  final CrossRefWithNoteDetails crossRef;
  final int currentNoteId;
  final VoidCallback onDelete;
  final VoidCallback onEdit;

  const CrossRefCard({
    super.key,
    required this.crossRef,
    required this.currentNoteId,
    required this.onDelete,
    required this.onEdit,
  });

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('MMM d, yyyy');
    final isOutgoing = crossRef.noteId == currentNoteId;
    final targetNoteId = isOutgoing ? crossRef.otherNoteId : crossRef.noteId;
    final targetTitle = isOutgoing ? crossRef.otherNoteTitle : crossRef.noteTitle;
    final targetPreview = isOutgoing ? crossRef.otherNotePreview : crossRef.notePreview;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: InkWell(
        onTap: () {
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => NoteDetailScreen(noteId: targetNoteId),
            ),
          );
        },
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header with direction and type
              Row(
                children: [
                  Icon(
                    isOutgoing ? Icons.arrow_forward : Icons.arrow_back,
                    size: 16,
                    color: isOutgoing ? Colors.blue : Colors.green,
                  ),
                  const SizedBox(width: 4),
                  Text(
                    isOutgoing ? 'Outgoing' : 'Incoming',
                    style: TextStyle(
                      fontSize: 12,
                      color: isOutgoing ? Colors.blue : Colors.green,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(width: 12),
                  Text(crossRef.referenceType.icon),
                  const SizedBox(width: 4),
                  Text(
                    crossRef.referenceType.displayName,
                    style: const TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const Spacer(),
                  PopupMenuButton(
                    itemBuilder: (context) => [
                      const PopupMenuItem(
                        value: 'edit',
                        child: Row(
                          children: [
                            Icon(Icons.edit, size: 18),
                            SizedBox(width: 8),
                            Text('Edit'),
                          ],
                        ),
                      ),
                      const PopupMenuItem(
                        value: 'delete',
                        child: Row(
                          children: [
                            Icon(Icons.delete, size: 18, color: Colors.red),
                            SizedBox(width: 8),
                            Text('Delete', style: TextStyle(color: Colors.red)),
                          ],
                        ),
                      ),
                    ],
                    onSelected: (value) {
                      if (value == 'edit') {
                        onEdit();
                      } else if (value == 'delete') {
                        onDelete();
                      }
                    },
                  ),
                ],
              ),
              const SizedBox(height: 8),

              // Target note title
              Text(
                targetTitle ?? 'Untitled Note',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 4),

              // Target note preview
              if (targetPreview != null) ...[
                Text(
                  targetPreview,
                  style: TextStyle(
                    fontSize: 14,
                    color: Colors.grey[700],
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 8),
              ],

              // Description
              if (crossRef.description != null && crossRef.description!.isNotEmpty) ...[
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.grey[100],
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Icon(Icons.comment, size: 14, color: Colors.grey[600]),
                      const SizedBox(width: 4),
                      Expanded(
                        child: Text(
                          crossRef.description!,
                          style: TextStyle(
                            fontSize: 12,
                            color: Colors.grey[700],
                            fontStyle: FontStyle.italic,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 8),
              ],

              // Footer with metadata
              Row(
                children: [
                  Text(
                    dateFormat.format(crossRef.createdAt),
                    style: TextStyle(
                      fontSize: 11,
                      color: Colors.grey[500],
                    ),
                  ),
                  const Spacer(),
                  if (crossRef.isAutoGenerated != 'manual') ...[
                    Icon(
                      Icons.auto_awesome,
                      size: 12,
                      color: Colors.grey[500],
                    ),
                    const SizedBox(width: 4),
                    Text(
                      crossRef.isAutoGenerated == 'ai_suggested'
                          ? 'AI Suggested'
                          : 'AI Generated',
                      style: TextStyle(
                        fontSize: 11,
                        color: Colors.grey[500],
                      ),
                    ),
                  ],
                  if (crossRef.confidenceScore != null) ...[
                    const SizedBox(width: 8),
                    Text(
                      '${crossRef.confidenceScore}% confidence',
                      style: TextStyle(
                        fontSize: 11,
                        color: Colors.grey[500],
                      ),
                    ),
                  ],
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

---

## Integration with Note Detail Screen

Add a button to the Note Detail Screen to view cross-references:

```dart
// Add this to NoteDetailScreen's AppBar actions
IconButton(
  icon: Badge(
    label: countAsync.when(
      data: (count) => Text(count.totalCrossRefs.toString()),
      loading: () => const Text('0'),
      error: (_, __) => const Text('0'),
    ),
    isLabelVisible: countAsync.maybeWhen(
      data: (count) => count.totalCrossRefs > 0,
      orElse: () => false,
    ),
    child: const Icon(Icons.link),
  ),
  onPressed: () {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => CrossRefsScreen(
          noteId: note.id,
          noteTitle: note.title,
        ),
      ),
    );
  },
),
```

---

## Key Features

‚úÖ **Create cross-references** between related notes  
‚úÖ **Multiple reference types** (related, references, expands_on, etc.)  
‚úÖ **Bidirectional navigation** view outgoing and incoming references  
‚úÖ **Reference statistics** total, outgoing, and incoming counts  
‚úÖ **Rich metadata** descriptions, AI-generated flags, confidence scores  
‚úÖ **Edit and delete** cross-references  
‚úÖ **Visual indicators** for reference direction and type  
‚úÖ **Bulk operations** create multiple references at once  

---

## Next Steps

- Implement AI-suggested cross-references
- Add visual graph view of note connections
- Export note network as graph
- Implement reference strength/weight
- Add filtering by reference type
- Implement smart suggestions based on content similarity

---

This completes the Flutter implementation guide for the Cross-Reference feature! üéâ
